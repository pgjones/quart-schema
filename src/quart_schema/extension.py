from __future__ import annotations

import inspect
import re
from collections import defaultdict
from functools import wraps
from types import new_class
from typing import Any, Callable, Dict, Iterable, List, Literal, Optional, Tuple, TypeVar, Union

import click
import humps
from quart import current_app, jsonify, Quart, render_template_string, ResponseReturnValue
from quart.cli import pass_script_info, ScriptInfo
from quart.json.provider import DefaultJSONProvider
from quart.typing import ResponseReturnValue as QuartResponseReturnValue
from werkzeug.routing.converters import AnyConverter, NumberConverter
from werkzeug.routing.rules import Rule

from .conversion import convert_response_return_value, model_schema
from .mixins import TestClientMixin, WebsocketMixin
from .openapi import (
    APIKeySecurityScheme,
    ExternalDocumentation,
    HttpSecurityScheme,
    Info,
    OAuth2SecurityScheme,
    OpenIdSecurityScheme,
    SecuritySchemeBase,
    Server,
    Tag,
)
from .typing import PydanticDumpOptions
from .validation import (
    DataSource,
    QUART_SCHEMA_HEADERS_ATTRIBUTE,
    QUART_SCHEMA_QUERYSTRING_ATTRIBUTE,
    QUART_SCHEMA_REQUEST_ATTRIBUTE,
    QUART_SCHEMA_RESPONSE_ATTRIBUTE,
)

try:
    from pydantic_core import to_jsonable_python
except ImportError:
    to_jsonable_python = None

try:
    from msgspec import to_builtins
except ImportError:
    to_builtins = None

T = TypeVar("T", bound=Callable)

SecurityScheme = Union[
    APIKeySecurityScheme,
    HttpSecurityScheme,
    OAuth2SecurityScheme,
    OpenIdSecurityScheme,
    SecuritySchemeBase,
]
SecuritySchemeInput = Union[
    APIKeySecurityScheme,
    HttpSecurityScheme,
    OAuth2SecurityScheme,
    OpenIdSecurityScheme,
    SecuritySchemeBase,
    dict,
]

QUART_SCHEMA_HIDDEN_ATTRIBUTE = "_quart_schema_hidden"
QUART_SCHEMA_TAG_ATTRIBUTE = "_quart_schema_tag"
QUART_SCHEMA_OPERATION_ID_ATTRIBUTE = "_quart_schema_operation_id"
QUART_SCHEMA_SECURITY_ATTRIBUTE = "_quart_schema_security_tag"
QUART_SCHEMA_DEPRECATED = "_quart_schema_deprecated"

PATH_RE = re.compile("<(?:[^:]*:)?([^>]+)>")

REDOC_TEMPLATE = """
<head>
  <title>{{ title }}</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }
  </style>
</head>
<body>
  <redoc spec-url="{{ openapi_path }}"></redoc>
  <script src="{{ redoc_js_url }}"></script>
  <noscript>This page requires Javascript to function.</noscript>
</body>
"""

SCALAR_TEMPLATE = """
<head>
  <title>{{ title }}</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>
<body>
  <script id="api-reference" data-url="{{ openapi_path }}"></script>
  <script src="{{ scalar_js_url }}"></script>
</body>
"""

SWAGGER_TEMPLATE = """
<head>
  <link type="text/css" rel="stylesheet" href="{{ swagger_css_url }}">
  <title>{{ title }}</title>
</head>
<body>
  <div id="swagger-ui"></div>
  <script src="{{ swagger_js_url }}"></script>
  <script>
    const ui = SwaggerUIBundle({
      deepLinking: true,
      dom_id: "#swagger-ui",
      layout: "BaseLayout",
      presets: [
        SwaggerUIBundle.presets.apis,
        SwaggerUIBundle.SwaggerUIStandalonePreset
      ],
      showExtensions: true,
      showCommonExtensions: true,
      url: "{{ openapi_path }}"
    });
  </script>
</body>
"""


def create_json_provider(app: Quart) -> DefaultJSONProvider:
    preference = app.config["QUART_SCHEMA_CONVERSION_PREFERENCE"]

    class JSONProvider(DefaultJSONProvider):
        @staticmethod
        def default(object_: Any) -> Any:
            try:
                return super().default(object_)
            except TypeError:
                if to_jsonable_python is not None and preference != "msgspec":
                    return to_jsonable_python(object_)
                elif to_builtins is not None and preference != "pydantic":
                    return to_builtins(object_)
                else:
                    raise

    return JSONProvider(app)


def hide(func: T) -> T:
    """Mark the func as hidden.

    This will prevent the route from being included in the
    autogenerated documentation.
    """
    setattr(func, QUART_SCHEMA_HIDDEN_ATTRIBUTE, True)
    return func


class QuartSchema:
    """A Quart-Schema instance.

    This can be used to initialise Quart-Schema documentation a given
    app, either directly,

    .. code-block:: python

        app = Quart(__name__)
        QuartSchema(app)

    or via the factory pattern,

    .. code-block:: python

        quart_schema = QuartSchema()

        def create_app():
            app = Quart(__name__)
            quart_schema.init_app(app)
            return app

    This can be customised using the following arguments,

    Arguments:
        openapi_path: The path used to serve the openapi json on, or None
            to disable documentation.
        redoc_ui_path: The path used to serve the documentation UI using
            redoc or None to disable redoc documentation.
        scalar_ui_path: The path used to serve the documentation UI using
            scalar or None to disable scalar documentation.
        swagger_ui_path: The path used to serve the documentation UI using
            swagger or None to disable swagger documentation.
        info: A OpenAPI Info object describing the API.
        tags: Specify the possible tags.
        convert_casing: If true casing will be converted in JSON.
        servers: Specify the server information.
        security_schemes: The security schemes to be configured for this app.
        security: The security schemes to apply globally (to all routes).
        external_docs: External documentation information.
    """

    def __init__(
        self,
        app: Optional[Quart] = None,
        *,
        openapi_path: Optional[str] = "/openapi.json",
        redoc_ui_path: Optional[str] = "/redocs",
        scalar_ui_path: Optional[str] = "/scalar",
        swagger_ui_path: Optional[str] = "/docs",
        info: Optional[Union[Info, dict]] = None,
        tags: Optional[List[Union[Tag, dict]]] = None,
        convert_casing: bool = False,
        servers: Optional[List[Union[Server, dict]]] = None,
        security_schemes: Optional[Dict[str, SecuritySchemeInput]] = None,
        security: Optional[List[Dict[str, List[str]]]] = None,
        external_docs: Optional[Union[ExternalDocumentation, dict]] = None,
        conversion_preference: Literal["msgspec", "pydantic", None] = None,
        pydantic_dump_options: Optional[PydanticDumpOptions] = None,
    ) -> None:
        self.openapi_path = openapi_path
        self.redoc_ui_path = redoc_ui_path
        self.scalar_ui_path = scalar_ui_path
        self.swagger_ui_path = swagger_ui_path

        self.convert_casing = convert_casing
        self.conversion_preference = conversion_preference
        self.pydantic_dump_options = {} if pydantic_dump_options is None else pydantic_dump_options

        self.info: Optional[Info] = None
        if info is not None:
            self.info = info if isinstance(info, Info) else Info(**info)

        self.tags: Optional[List[Tag]] = None
        if tags is not None:
            self.tags = [tag if isinstance(tag, Tag) else Tag(**tag) for tag in tags]

        self.servers: Optional[List[Server]] = None
        if servers is not None:
            self.servers = [
                server if isinstance(server, Server) else Server(**server) for server in servers
            ]

        self.security_schemes: Optional[Dict[str, SecurityScheme]] = None
        if security_schemes is not None:
            self.security_schemes = {}
            for key, value in security_schemes.items():
                if isinstance(value, dict):
                    if value["type"] == "apiKey":
                        self.security_schemes[key] = APIKeySecurityScheme(**value)
                    elif value["type"] == "http":
                        self.security_schemes[key] = HttpSecurityScheme(**value)
                    elif value["type"] == "oauth2":
                        self.security_schemes[key] = OAuth2SecurityScheme(**value)
                    elif value["type"] == "openIdConnect":
                        self.security_schemes[key] = OpenIdSecurityScheme(**value)
                    else:
                        self.security_schemes[key] = SecuritySchemeBase(**value)
                else:
                    self.security_schemes[key] = value

        self.security = security

        self.external_docs: Optional[ExternalDocumentation] = None
        if external_docs is not None:
            self.external_docs = (
                external_docs
                if isinstance(external_docs, ExternalDocumentation)
                else ExternalDocumentation(**external_docs)
            )

        if app is not None:
            self.init_app(app)

    def init_app(self, app: Quart) -> None:
        app.extensions["QUART_SCHEMA"] = self

        if self.info is None:
            self.info = Info(title=app.name, version="0.1.0")

        app.test_client_class = new_class("TestClient", (TestClientMixin, app.test_client_class))
        app.websocket_class = new_class(  # type: ignore
            "Websocket", (WebsocketMixin, app.websocket_class)
        )
        app.make_response = wrap_make_response(app.make_response)  # type: ignore

        app.config.setdefault(
            "QUART_SCHEMA_SWAGGER_JS_URL",
            "https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.4.2/swagger-ui-bundle.js",
        )
        app.config.setdefault(
            "QUART_SCHEMA_SWAGGER_CSS_URL",
            "https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.4.2/swagger-ui.min.css",
        )
        app.config.setdefault(
            "QUART_SCHEMA_REDOC_JS_URL",
            "https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js",
        )
        app.config.setdefault(
            "QUART_SCHEMA_SCALAR_JS_URL",
            "https://cdn.jsdelivr.net/npm/@scalar/api-reference",
        )
        app.config.setdefault("QUART_SCHEMA_PYDANTIC_DUMP_OPTIONS", self.pydantic_dump_options)
        app.config.setdefault("QUART_SCHEMA_CONVERT_CASING", self.convert_casing)
        app.config.setdefault("QUART_SCHEMA_CONVERSION_PREFERENCE", self.conversion_preference)
        app.json = create_json_provider(app)

        if self.openapi_path is not None:
            hide(app.send_static_file.__func__)  # type: ignore
            app.add_url_rule(self.openapi_path, "openapi", self.openapi)
            if self.redoc_ui_path is not None:
                app.add_url_rule(self.redoc_ui_path, "redoc_ui", self.redoc_ui)
            if self.scalar_ui_path is not None:
                app.add_url_rule(self.scalar_ui_path, "scalar_ui", self.scalar_ui)
            if self.swagger_ui_path is not None:
                app.add_url_rule(self.swagger_ui_path, "swagger_ui", self.swagger_ui)

        app.cli.add_command(_schema_command)

    @hide
    async def openapi(self) -> ResponseReturnValue:
        return jsonify(_build_openapi_schema(current_app, self))

    @hide
    async def swagger_ui(self) -> str:
        return await render_template_string(
            SWAGGER_TEMPLATE,
            title=self.info.title,
            openapi_path=self.openapi_path,
            swagger_js_url=current_app.config["QUART_SCHEMA_SWAGGER_JS_URL"],
            swagger_css_url=current_app.config["QUART_SCHEMA_SWAGGER_CSS_URL"],
        )

    @hide
    async def redoc_ui(self) -> str:
        return await render_template_string(
            REDOC_TEMPLATE,
            title=self.info.title,
            openapi_path=self.openapi_path,
            redoc_js_url=current_app.config["QUART_SCHEMA_REDOC_JS_URL"],
        )

    @hide
    async def scalar_ui(self) -> str:
        return await render_template_string(
            SCALAR_TEMPLATE,
            title=self.info.title,
            openapi_path=self.openapi_path,
            scalar_js_url=current_app.config["QUART_SCHEMA_SCALAR_JS_URL"],
        )


@click.command("schema")
@click.option(
    "--output",
    "-o",
    type=click.Path(),
    help="Output the spec to a file given by a path.",
)
@pass_script_info
def _schema_command(info: ScriptInfo, output: Optional[str]) -> None:
    app = info.load_app()
    schema = _build_openapi_schema(app, app.extensions["QUART_SCHEMA"])
    formatted_spec = app.json.dumps(schema, indent=2)
    if output is not None:
        with open(output, "w") as file_:
            click.echo(formatted_spec, file=file_)
    else:
        click.echo(formatted_spec)


def _split_definitions(schema: dict) -> Tuple[dict, dict]:
    new_schema = schema.copy()
    definitions = new_schema.pop("$defs", {})
    return definitions, new_schema


def _split_convert_definitions(schema: dict, convert_casing: bool) -> Tuple[dict, dict]:
    definitions, new_schema = _split_definitions(schema)
    if convert_casing:
        new_schema = humps.camelize(new_schema)
        if "required" in new_schema:
            new_schema["required"] = [humps.camelize(field) for field in new_schema["required"]]
        definitions = {key: humps.camelize(definition) for key, definition in definitions.items()}
        for key, definition in definitions.items():
            if "required" in definition:
                definition["required"] = [humps.camelize(field) for field in definition["required"]]
    return definitions, new_schema


def wrap_make_response(func: Callable) -> Callable:
    @wraps(func)
    async def decorator(result: ResponseReturnValue) -> QuartResponseReturnValue:
        return await func(convert_response_return_value(result))

    return decorator


def operation_id(operationid: str) -> Callable[[T], T]:
    """Override the operationId of the route.

    This allows for overriding the operationId, which is normally calculated from the
    function name. The HTTP method will still be prepended to the overridden name.

    Arguments:
        operationid: The operation ID to associate.

    """

    def decorator(func: T) -> T:
        setattr(func, QUART_SCHEMA_OPERATION_ID_ATTRIBUTE, str(operationid))

        return func

    return decorator


def tag(tags: Iterable[str]) -> Callable[[T], T]:
    """Add tag names to the route.

    This allows for tags to be associated with the route, thereby
    allowing control over which routes are shown in the documentation.

    Arguments:
        tags: A List (or iterable) of tags to associate.

    """

    def decorator(func: T) -> T:
        setattr(func, QUART_SCHEMA_TAG_ATTRIBUTE, set(tags))

        return func

    return decorator


def deprecate(func: T) -> T:
    """Mark endpoint as deprecated."""
    setattr(func, QUART_SCHEMA_DEPRECATED, True)

    return func


def security_scheme(schemes: Iterable[Dict[str, List[str]]]) -> Callable[[T], T]:
    """Add security schemes to the route.

    Allows security schemes to be associated with this route. Security
    schemes first need to be defined on the constructor and can be
    referenced here by name.

    Arguments:
        schemes: A List (or iterable) of security schemes to associate.

    """

    def decorator(func: T) -> T:
        setattr(func, QUART_SCHEMA_SECURITY_ATTRIBUTE, schemes)

        return func

    return decorator


def _build_path(func: Callable, rule: Rule, app: Quart) -> Tuple[dict, dict]:
    components = {}
    operation_object: Dict[str, Any] = {
        "parameters": [],
        "responses": {},
    }
    if func.__doc__ is not None:
        summary, *description = inspect.getdoc(func).splitlines()
        operation_object["description"] = "\n".join(description)
        operation_object["summary"] = summary

    if getattr(func, QUART_SCHEMA_TAG_ATTRIBUTE, None) is not None:
        operation_object["tags"] = list(getattr(func, QUART_SCHEMA_TAG_ATTRIBUTE))

    if getattr(func, QUART_SCHEMA_DEPRECATED, None):
        operation_object["deprecated"] = True

    if getattr(func, QUART_SCHEMA_SECURITY_ATTRIBUTE, None) is not None:
        operation_object["security"] = list(getattr(func, QUART_SCHEMA_SECURITY_ATTRIBUTE))

    response_models = getattr(func, QUART_SCHEMA_RESPONSE_ATTRIBUTE, {})
    for status_code in response_models.keys():
        model_class, headers_model_class = response_models[status_code]
        schema = model_schema(
            model_class,
            preference=app.config["QUART_SCHEMA_CONVERSION_PREFERENCE"],
            schema_mode="serialization",
        )
        definitions, schema = _split_convert_definitions(
            schema, app.config["QUART_SCHEMA_CONVERT_CASING"]
        )
        components.update(definitions)
        response_object = {
            "content": {
                "application/json": {
                    "schema": schema,
                },
            },
            "description": "",
        }
        if model_class.__doc__ is not None:
            response_object["description"] = inspect.getdoc(model_class)

        if headers_model_class is not None:
            schema = model_schema(
                headers_model_class,
                preference=app.config["QUART_SCHEMA_CONVERSION_PREFERENCE"],
            )
            definitions, schema = _split_definitions(schema)
            components.update(definitions)
            response_object["content"]["headers"] = {  # type: ignore
                name.replace("_", "-"): {
                    "schema": type_,
                }
                for name, type_ in schema["properties"].items()
            }
        operation_object["responses"][status_code] = response_object

    request_data = getattr(func, QUART_SCHEMA_REQUEST_ATTRIBUTE, None)
    if request_data is not None:
        schema = model_schema(
            request_data[0], preference=app.config["QUART_SCHEMA_CONVERSION_PREFERENCE"]
        )
        definitions, schema = _split_convert_definitions(
            schema, app.config["QUART_SCHEMA_CONVERT_CASING"]
        )
        components.update(definitions)

        if request_data[1] == DataSource.JSON:
            encoding = "application/json"
        elif request_data[1] == DataSource.FORM_MULTIPART:
            encoding = "multipart/form-data"
        else:
            encoding = "application/x-www-form-urlencoded"

        operation_object["requestBody"] = {
            "content": {
                encoding: {
                    "schema": schema,
                },
            },
        }

    querystring_model = getattr(func, QUART_SCHEMA_QUERYSTRING_ATTRIBUTE, None)
    if querystring_model is not None:
        schema = model_schema(
            querystring_model, preference=app.config["QUART_SCHEMA_CONVERSION_PREFERENCE"]
        )
        definitions, schema = _split_convert_definitions(
            schema, app.config["QUART_SCHEMA_CONVERT_CASING"]
        )
        components.update(definitions)
        for name, type_ in schema["properties"].items():
            param = {"name": name, "in": "query", "schema": type_}

            for attribute in ("description", "required", "deprecated"):
                if attribute in type_:
                    param[attribute] = type_.pop(attribute)

            operation_object["parameters"].append(param)

    headers_model = getattr(func, QUART_SCHEMA_HEADERS_ATTRIBUTE, None)
    if headers_model is not None:
        schema = model_schema(
            headers_model, preference=app.config["QUART_SCHEMA_CONVERSION_PREFERENCE"]
        )
        definitions, schema = _split_definitions(schema)
        components.update(definitions)
        for name, type_ in schema["properties"].items():
            param = {"name": name.replace("_", "-"), "in": "header", "schema": type_}

            for attribute in ("description", "required", "deprecated"):
                if attribute in type_:
                    param[attribute] = type_.pop(attribute)

            operation_object["parameters"].append(param)

    for name, converter in rule._converters.items():
        type_ = "string"
        if isinstance(converter, NumberConverter):
            type_ = "number"

        if isinstance(converter, AnyConverter):
            schema["enum"] = list(converter.items)
        else:
            schema = {"type": type_}

        operation_object["parameters"].append(
            {
                "name": name,
                "in": "path",
                "required": True,
                "schema": schema,
            }
        )

    path = re.sub(PATH_RE, r"{\1}", rule.rule)
    paths = {path: {}}  # type: ignore

    for method in rule.methods:
        if method == "HEAD" or (method == "OPTIONS" and rule.provide_automatic_options):  # type: ignore # noqa: E501
            continue

        per_method_operation_object = operation_object.copy()

        if getattr(func, QUART_SCHEMA_OPERATION_ID_ATTRIBUTE, None) is not None:
            per_method_operation_object["operationId"] = (
                f"{method.lower()}_{getattr(func, QUART_SCHEMA_OPERATION_ID_ATTRIBUTE)}"
            )
        else:
            per_method_operation_object["operationId"] = f"{method.lower()}_{func.__name__}"

        paths[path][method.lower()] = per_method_operation_object
    return paths, components


def _build_full_schema(extension: QuartSchema, paths: dict, component_schemas: dict) -> dict:
    components = {"schemas": component_schemas}
    if extension.security_schemes is not None:
        components["securitySchemes"] = {
            key: value.schema(camelize=True) for key, value in extension.security_schemes.items()
        }

    openapi_schema: dict = {
        "openapi": "3.1.0",
        "info": extension.info.schema(camelize=True),
        "components": components,
        "paths": paths,
    }
    if extension.tags is not None:
        openapi_schema["tags"] = [tag.schema(camelize=True) for tag in extension.tags]
    if extension.security is not None:
        openapi_schema["security"] = extension.security
    if extension.servers is not None:
        openapi_schema["servers"] = [server.schema(camelize=True) for server in extension.servers]
    if extension.external_docs is not None:
        openapi_schema["externalDocs"] = extension.external_docs.schema(camelize=True)

    return openapi_schema


def _build_openapi_schema(app: Quart, extension: QuartSchema) -> dict:
    paths: Dict[str, dict] = defaultdict(dict)
    component_schemas = {}
    for rule in app.url_map.iter_rules():
        if rule.websocket:
            continue

        func = app.view_functions[rule.endpoint]
        if getattr(func, QUART_SCHEMA_HIDDEN_ATTRIBUTE, False):
            continue

        built_paths, components = _build_path(func, rule, app)

        for path in built_paths:
            paths[path].update(built_paths[path])
        component_schemas.update(components)

    return _build_full_schema(extension, paths, component_schemas)
